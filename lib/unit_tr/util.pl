:- module(util, [
	      context_var/2,
	      mem_var/2,
	      distinct_vars/1,
	      ground_vars/2,
	      select_var/3,
	      extract/4,
	      rename_vars/3,
	      get_pred_definition/3,
	      get_declarations/3,
	      get_clause_line/3,
	      get_atm/2,
	      drop_qualifiers/2
		]).





%pred(context_var(var, list(typed_var))).
%  context_var(?X, +C):  X is a variable of context C
context_var(X,[V:_|L]) :-
	X==V,!
	;
	context_var(X,L).

%pred(mem_var(var, list(var))).
%  mem_var(?X, +L):   X is a variable of L
mem_var(X,[V|L]) :-
	X==V,!
	;
	mem_var(X,L).

%pred(distinct_vars(list(var))).
%  distinct_vars(+L):  L is a list of distinct vars
distinct_vars(V) :-
	distinct_vars(V,[]).

%local_pred(distinct_vars(list(var), list(var))).
distinct_vars([],_).
distinct_vars([X|V],V1) :-
	not(mem_var(X,V1)),
	distinct_vars(V,[X|V1]).

%pred(ground_vars(atom, any)).
%  ground_vars(+N, @Term):
%  side-effect:  Term is grounded by substituting each variable
%  with a new name N_k:  e.g.
%  ?- Term = f(A,B), ground_vars(x, Term).
%  A=x1
%  B=x2
%  Term=f(x1,x2)
%
ground_vars(Name, A) :-
	term_variables(A, Vars),
	reset_gensym(Name),
	maplist(to_g(Name), Vars).

%local_pred(to_g(atom, var)).
% to_g(+N, @X)  substitutes X by Nk,
% k generated by gensym
to_g(Name, X) :-
	gensym(Name, V),
	X=V.

select_var(X:T, [Y:T|L], L) :-
	X==Y, !.
select_var(X:T, [_|L], L1) :-
	select_var(X:T, L,L1).


extract([X:T|L], L1, L2,  E) :-
	select_var(X:T1, L1, LA), !,
	%extract from branch 2
	extract2(T1, [X:T|L], LA, L2, E).
extract([X:_T|L], L1, L2,  [X:T2|E]) :-
	% X only in branch 2, type T2
	select_var(X:T2, L2, LB),!,
	extract(L,L1,LB,E).
extract([X:T|L], L1, L2,  [X:T|E]) :- !,
	%no branch, call type is preserved
	extract(L,L1,L2,E).
extract([], [W1|L1], [W2|L2],  [W1, W2|E]) :-!,
	%common variables already extracted, make the union
	extract([],L1,L2,E).
extract([], [], [W|L], [W|L]).
extract([], [W|L], [], [W|L]).
extract([], [], [], []).

extract2(_T1, [X:T|L], LA, L2, [X:T|E]) :-
	select_var(X:_,L2,LB), !,
	%  X in branch 1 and 2, call type is assumed
	extract(L,LA,LB,E).
extract2(T1, [X:_T|L], LA, L2, [X:T1|E]) :-!,
	%  X only in branch 1, type T1
	extract(L,LA,L2,E).

rename_var(V/W, V1, W) :-
	V1==V, !.
rename_var(_, V, V) :-
	var(V),!.
rename_var(S, Term, RTerm) :-
	Term =.. [F|Args],
	maplist(rename_var(S), Args, RArgs),
	RTerm =.. [F|RArgs].
rename_vars(C, Term1, Term2) :-
	term_variables(Term1, Vars),
	rename_non_context_vars(C, Vars, Term1, Term2).

rename_non_context_vars(_C, [], Term, Term).
rename_non_context_vars(C, [V|Vars], Term1, Term2) :-
	context_var(V,C), !,
	rename_non_context_vars(C, Vars, Term1, Term2).
rename_non_context_vars(C, [V|Vars], Term1, Term2) :-
	rename_var(V/_, Term1, Term), !,
	rename_non_context_vars(C, Vars, Term, Term2).



get_declarations(File, DeclSymbol, Decls) :-
	open(File, read, Stream),
	get_decl(Stream, DeclSymbol, FirstDecl, Pos, _),!,
	get_next_decls(Stream, DeclSymbol, FirstDecl, Pos, [], Decls),
	close(Stream).

get_decl(Stream, _, at_end, _, _) :-
	at_end_of_stream(Stream), !.
get_decl(Stream, DeclSymbol/N, Decl, Pos, Comments) :-
	read_term(Stream, Term, [term_position(TermPos), comments(TermComments)]),!,
	(
	functor(Term, DeclSymbol, N), !,
	Decl=Term,
	Pos=TermPos,
	Comments=TermComments
	;
	get_decl(Stream, DeclSymbol/N, Decl, Pos, Comments)
	).

get_next_decls(_Stream, _, at_end, _Pos, Decls, Decls) :-!.
get_next_decls(Stream, DeclSymbol/N, Previous, Pos, Decls1, [PrevDecl|Decls2]) :-
	read_term(Stream, Term, [term_position(TermPos), comments(Comments)]),
	make_decl(Previous, Pos, Comments, PrevDecl),!,
	(   functor(Term, DeclSymbol, N), !,
	    get_next_decls(Stream, DeclSymbol/N, Term, TermPos, Decls1, Decls2)
	;   get_decl(Stream, DeclSymbol/N, NewDecl, NewPos, _),!,
	    get_next_decls(Stream, DeclSymbol/N, NewDecl, NewPos, Decls1, Decls2)
	).

make_decl(Decl,Pos,Comments,decl(Decl,Pos,Commentlist)) :-
	to_comment_list(Comments,[],Commentlist).


get_pred_definition(File, Head, Clauses) :-
	open(File, read, Stream),
	read_clauses(Stream, Head, [], Clauses),!,
	close(Stream).

get_clause_line(File, Clause, Position) :-
	open(File, read, Stream),
	search_clause(Stream, Clause, Position),
	close(Stream).
search_clause(Stream, _, _Position) :-
	at_end_of_stream(Stream),!,
	fail.
search_clause(Stream, Clause, Line) :-
	not(at_end_of_stream(Stream)),
	read_clause(Stream, CL, [term_position(Pos)]),!,
	(   same_head(Clause, CL) ,
	    arg(2,Pos,Line), !
	;   search_clause(Stream, Clause, Line)).


same_head(clause(_,Head1,true), Head2) :-
	Head2 \= (:- _),
	Head2 \= (_:-_),
	get_atm(Head1, H),
	get_atm(Head2,H).
same_head(clause(_,Head1,_Body1), (Head2:- _Body2)) :-
	get_atm(Head1, H),
	get_atm(Head2,H).

read_clauses(Stream, _, Clauses, Clauses) :-
	at_end_of_stream(Stream), !.
read_clauses(Stream, Pred, Clauses1, Clauses2) :-
	read_clause(Stream, CL, [term_position(Pos), comments(Comment)]),!,
	get_attributes(Pos, Comment, Attr),
	add_clause(CL, Pred, Attr, Clauses1, Clauses),
	read_clauses(Stream, Pred, Clauses, Clauses2).

add_clause(CL, Pred, Attributes, Cl1, Cl2) :-
	functor(Pred,P,N),
	functor(Head,P,N),
	(   CL=Head ->
	    Cl2 = [clause(Head,true,Attributes)|Cl1]
	;   CL=(Head:-Body) ->
	    Cl2 = [clause(Head,Body,Attributes)|Cl1]
	;   Cl1=Cl2
	).

get_attributes(Pos, Comments, [line(N), comment(C)]):-
	arg(2,Pos,N),
	to_comment_list(Comments,[],C).

to_comment_list([], C, C).
to_comment_list([_Pos - Comm|L], C1, [NComm|C2]) :-
	normalize(Comm, NComm), !,
	%writeln(Comm:NComm),
	to_comment_list(L, C1, C2).

normalize(Comm,"") :-
	string_concat("%==", _, Comm), !.
normalize(Comm, Before) :-
	sub_string(Comm, N1, _, _, "\n%=="),!,
	sub_string(Comm, 0, N1, _, Before).
normalize(Comm, Comm).



get_atm(_:At,Atm) :-!,
	get_atm(At,Atm).
get_atm(At,At).

drop_qualifiers(_:QE, E) :- !,
	drop_qualifiers(QE, E).
drop_qualifiers(E, E).

